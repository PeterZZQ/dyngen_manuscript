---
title: "Usecase Trajectory Alignment"
author: "Louise Deconinck"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Usecase Trajectory Alignment}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

When developing a way to align developmental trajectories, dyngen can be used as a tool to benchmark certain aspects that such a method should ideally possess. In this vignette, we will compare a couple of different approaches to trajectory alignment. 

Currently, dynamic time warping is most often used to compare trajectories with each other. Sometimes, *pseudocells* are introduced and gene expression at those cells is interpolated/smoothed. We will compare both the method that uses these pseudocells and a method that does not.

In order to test this, we will generate two experiments with dyngen, but with the same underlying topology, gene regulatory network and kinetics. We do sample different cells and generate a different experiment, which will introduce some relevant noise in the datasets.
If we compare both trajectories, we expect to discover the same trajectory, with a warping path that does not deviate substantially from the diagonal.

## Load packages

```{r, loadpackages, cache=TRUE, collapse=TRUE}
library(tidyverse)
library(dyngen)
library(dynplot)
library(dtw)

```


## Generating data

First, we generate some data. The backbone present in this process will be linear. We then initialize the model, generate the transcription factors and the feature network. Next, we generate the kinetics, gold standard, cells and experiment.

```{r, generatedata, collapse=TRUE, cache=TRUE}
backbone <- bblego(
  bblego_start("A", type = "simple", num_modules = 4),
  bblego_linear("A", "B", type = "doublerep1", num_modules = 6),
  bblego_linear("B", "C", type = "doublerep2", num_modules = 6),
  bblego_end("C", type = "simple", num_modules = 4)
)

nr_cells <- 1000

model_init <-
  initialise_model(
    num_tfs = 100,
    num_targets = 200,
    num_hks = 200,
    num_cells = nr_cells,
    backbone = backbone,
    verbose = TRUE,
    download_cache_dir = "~/.cache/dyngen",
    num_cores = 8,
    distance_metric = "pearson",
    tf_network_params = tf_network_default(min_tfs_per_module = 2, sample_num_regulators = function() 1),
    simulation_params = simulation_default(num_simulations = 10, census_interval = .01),
    experiment_params = experiment_snapshot(sample_capture_rate = function(n) rnorm(n, 1, 0.1))
  ) %>%
  generate_tf_network() %>%
  generate_feature_network()

model_unperturbed <- generate_kinetics(model_init) %>%
  generate_gold_standard() %>%
  generate_cells()

# We store this in a different variable because it is easier to plot the same 
# models in the same dimensionality reduction if the experiment is not yet 
# generated. This does not cause a significant difference with regard to 
# the actual experiments.
model_unperturbed_ <- generate_experiment(model_unperturbed)
dataset_unperturbed <- wrap_dataset(model_unperturbed_)
```

As explained in the introduction, we will generate new cells and a new experiment that should contain the same trajectory. 

```{r, generate_repl_data, collapse=TRUE, cache=TRUE, dependson=c("generatedata")}
model_replicate <- generate_cells(model_unperturbed)

# Same reasons as for the unperturbed data
model_replicate_ <- generate_experiment(model_replicate)
dataset_replicate <- wrap_dataset(model_replicate_)
```

If we merge these two datasets and plot them, with the included trajectories, we can definitely see that the trajectories present in the data are the same.

```{r, merge_data, collapse=TRUE, cache=TRUE, dependson=c("generatedata", "generate_repl_data")}
# Function to merge two models. Specifics are not important.
merge_models <- function(model, model1, model2){
  model12 <- model
  model12$feature_info <- model$feature_info %>%
    mutate(
      w = paste0("w_", feature_id),
      x = paste0("x_", feature_id),
      y = paste0("y_", feature_id)
    )
  m1gs <- model1$gold_standard
  m2gs <- model2$gold_standard
  model12$gold_standard <- list(
    meta = bind_rows(
      m1gs$meta %>% mutate_at(c("from", "to", "from_", "to_"), ~paste0("left_", .)),
      m2gs$meta %>% mutate_at(c("from", "to", "from_", "to_"), ~paste0("right_", .))
    ),
    counts = rbind(
      m1gs$counts,
      m2gs$counts
    ),
    network = bind_rows(
      m1gs$network %>% mutate_at(c("from", "to"), ~paste0("left_", .)),
      m2gs$network %>% mutate_at(c("from", "to"), ~paste0("right_", .))
    )
  )
  m1sim <- model1$simulations
  m2sim <- model2$simulations
  num_m1sim <- max(m1sim$meta$simulation_i)
  model12$simulations <- list(
    meta = bind_rows(
      m1sim$meta %>% mutate_at(c("from", "to"), ~paste0("left_", .)),
      m2sim$meta %>% mutate_at(c("from", "to"), ~paste0("right_", .)) %>% mutate(simulation_i = simulation_i + num_m1sim)
    ),
    counts = rbind(
      m1sim$counts,
      m2sim$counts
    ),
    regulation = rbind(
      m1sim$regulation,
      m2sim$regulation
    ),
    reaction_firings = rbind(
      m1sim$reaction_firings,
      m2sim$reaction_firings
    ),
    reaction_propensities = rbind(
      m1sim$reaction_propensities,
      m2sim$reaction_propensities
    )
  )
  model12
}

model_merged <- merge_models(model_init, model_unperturbed, model_replicate)

model_merged <- model_merged %>%
  dyngen:::calculate_dimred(dimred_premrna = FALSE) %>%
  generate_experiment()

```

```{r, plot_simulations_dimred, collapse=TRUE, fig.height=7, fig.width=7, fig.align = "center", results='hold', cache=TRUE, dependson=c("merge_data")}
dataset_merged <- wrap_dataset(model_merged)
plot_gold_simulations(model_merged)
plot_dimred(dataset_merged)
```

## Apply dynamic time warping

Next, we will apply dynamic time warping to the two trajectories. Dynamic time warping is a method that searches the lowest cost necessary to align two time series. A dissimilarity matrix is calculated, that calculates the distance between all cells in the two trajectories. Then the path in the matrix that minimizes the overall distance of the alignment is calculated. The path is constrained be the allowed steps, which can be defined in multiple ways. We will mainly use the "symmetric2" pattern, which allows the path to proceed diagonally, vertically and horizontally for one step, but the cost for a diagonal step is double. (This is because the diagonal path is twice as short as the correspoinding vertical & horizontal path.)

### Smooth gene expression
```{r, dtw_functions, include=FALSE}

# Define methods to add waypoints/smooth etc

library(tidyverse)
library(dyngen)
library(dynplot)
library(gtools)
library(dtw)

calculate_correct_pseudotime <- function(dataset){
  length_pieces <- dataset$milestone_network$length/sum(dataset$milestone_network$length)
  nr_piece <- 0
  start <- "sA"
  traj <- numeric()
  names_traj <- list()
  # TODO convert to for for each piece
  while(start %in% dataset$milestone_network[["from"]]){
    idx <- which(start == dataset$milestone_network[["from"]])[[1]]
    end <- dataset$milestone_network[["to"]][idx]
    to_add <- sum(length_pieces[0:nr_piece])

    perc <-(dataset[["progressions"]] %>% filter(from == start & to == end))$percentage * length_pieces[nr_piece + 1] + to_add
    nams <-(dataset[["progressions"]] %>% filter(from == start & to == end))$cell_id

    traj <- c(traj, perc)
    names_traj <- c(names_traj, nams)

    start <- end
    print(start)
    nr_piece <- nr_piece + 1

  }

  names(traj) <- names_traj
  traj <- traj[mixedorder(names(traj))]
  traj
}

get_geodesic_distances_from_progressions <- function(dataset, waypoint_progressions){
  waypoint_milestone_percentages <- dynwrap::convert_progressions_to_milestone_percentages(cell_id, dataset$milestone_ids, dataset$milestone_network, waypoint_progressions)
  waypoint_milestone_percentages <- dplyr::rename(waypoint_milestone_percentages, waypoint_id = cell_id)

  geodesic_distances <- dynwrap::calculate_geodesic_distances(dataset, waypoint_milestone_percentages = waypoint_milestone_percentages, directed=FALSE)
  geodesic_distances
}

get_waypoint_progression <- function(dataset, nr){
  cell_id <- character()
  froms <- character()
  tos <- character()
  percentage <- numeric()

  length_pieces <- dataset$milestone_network$length/sum(dataset$milestone_network$length)
  idx <- 1
  for(piece in length_pieces){
    amount <- round(nr * piece)
    wps <- modify(list(1:amount), function(x){x/amount})[[1]]
    ids <- modify(list(1:amount), function(x){sprintf("w%d_%03d", idx, x)})[[1]]
    from <- rep(dataset$milestone_network$from[idx], amount)
    to <- rep(dataset$milestone_network$to[idx], amount)

    cell_id <- c(cell_id, ids)
    froms <- c(froms, from)
    tos <- c(tos, to)
    percentage <- c(percentage, wps)

    idx <- idx + 1

  }
  waypoint_progressions <- tibble(cell_id=cell_id, from=froms, to=tos, percentage=percentage)
  waypoint_progressions
}

interpolate_expression <- function(dataset, wps, gds){
  weighted_expr <- do.call('cbind', lapply(seq_along(wps), function(idx){
    dist <- gds[idx,]
    weighted <- exp(-(dist^2)/(0.1)^2)
    weighted <- weighted/sum(weighted)
    weighted_exp <- t(as.matrix(dataset$counts)) %*% weighted
    weighted_exp
  }))
  weighted_expr
}

```

In order to smooth the gene expression, we construct a number of *psuedopoints* or *waypoints*. We place them equidistantly according to the pseudotime values. If a certain branch of the trajectory is twice as long as another branch, twice as many waypoints will be placed on that branch compared to the other branch.

We then determine the distance from these waypoints to all other cells present in the corresponding dataset. Taking these geodesic distances (distance along the trajectory graph) into account, we interpolate the gene expression values of these waypoints.

Finally, we calculate the dynamic time warping between the two datasets.

```{r, smooth_dtw, collapse=TRUE, fig.height=7, fig.width=7, fig.align = "center", results='hold', cache=TRUE, dependson=c("generatedata", "generate_repl_data")}
nr_wps <- nr_cells

wpp1 <- get_waypoint_progression(dataset_unperturbed, nr_wps)
wpp2 <- get_waypoint_progression(dataset_replicate, nr_wps)

gd1 <- get_geodesic_distances_from_progressions(dataset_unperturbed, wpp1)
gd2 <- get_geodesic_distances_from_progressions(dataset_replicate, wpp2)

wexpr1 <- interpolate_expression(dataset_unperturbed, wpp1$percentage, gd1)
wexpr2 <- interpolate_expression(dataset_replicate, wpp2$percentage, gd2)

# wexpr1 <- wexpr1[1:100,]
# wexpr2 <- wexpr2[1:100,]

d2 <- dist(as.matrix(t(wexpr1)), as.matrix(t(wexpr2)), dist.method="correlation")
am2 <- dtw(d2, step.pattern = symmetric2, keep.internals = TRUE, open.end = TRUE)
```


### Don't smooth gene expression

Here we simply use the count matrices of both datasets to calculate the distances between the two trajectories. 

```{r, no_smooth_dtw, collapse=TRUE, fig.height=7, fig.width=7, fig.align = "center", results='hold', cache=TRUE, dependson=c("generatedata", "generate_repl_data")}
nor1 <- names(sort(calculate_correct_pseudotime(dataset_unperturbed)))
volg1 <- sapply(nor1, function(i) strtoi(substr(i, 5, 7)))
cnt1 <- as.matrix(dataset_unperturbed$counts)
cnts1 <- cnt1[volg1,]

nor2 <- names(sort(calculate_correct_pseudotime(dataset_replicate)))
volg2 <- sapply(nor2, function(i) strtoi(substr(i, 5, 7)))
cnt2 <- as.matrix(dataset_replicate$counts)
cnts2 <- cnt2[volg2,]

# cnts1 <- cnts1[,1:100]
# cnts2 <- cnts2[,1:100]

d3 <- dist(cnts1, cnts2, dist.method="correlation")
am3 <- dtw(d3, step.pattern = symmetric2, keep.internals = TRUE, open.end = TRUE)
```

### Compare both

We plot the smoothed and unsmoothed dtw graphs of these two datasets. We can see an obvious valley where the warping path lies in the case of the smoothed dtw. The graph with the unsmoothed dtw does not really show such a valley. Nonetheless, a diagonal warping path is found.

```{r, fig_comparison, collapse=TRUE, fig.height=7, fig.width=7, fig.align = "center", results='hold', cache=TRUE, dependson=c("no_smooth_dtw", "smooth_dtw")}

dtwPlotDensity(am2)
abline(coef= c(0,1))
dtwPlotDensity(am3)
abline(coef = c(0,1))
```

We can also compare the two dtw's quantitatively. The signal we want to capture is a warping path that lies on the diagonal. We can calculate either the area between the diagonal and the warping path or the sum of the absolute euclidean distance between the diagonal and the warping path, per x value.

```{r, compare_dtw, cache=TRUE, dependson=c("no_smooth_dtw", "smooth_dtw")}
library(MESS)

get_y_indices <- function(nr_points, index1, index2){
  xymap <- rep(list(), length = nr_points)
  for(i in 1:length(index1)){
    x_index = index1[[i]]
    y_index = index2[[i]]
    xymap[[x_index]] <- c(xymap[[x_index]], y_index)
  }

  sapply(sequence(nr_points), function(i) max(xymap[[i]]))
}

eucl_dist <- function(x1, x2, y1, y2){
  sqrt((x1 - x2)^2 + (y1 - y2)^2)
}

nr_x <- length(unique(am2$index1))

y_indices_smooth <- get_y_indices(length(unique(am2$index1)), am2$index1, am2$index2)
y_indices_no_smooth <- get_y_indices(length(unique(am2$index1)), am3$index1, am3$index2)

area_smooth <- MESS::auc(sequence(nr_x), y_indices_smooth - sequence(nr_x), absolutearea = TRUE)
dist_smooth <- sum(eucl_dist(sequence(nr_x), sequence(nr_x), y_indices_smooth, sequence(nr_x)))

area_no_smooth <- MESS::auc(sequence(nr_x), y_indices_no_smooth - sequence(nr_x), absolutearea = TRUE)
dist_no_smooth <- sum(eucl_dist(sequence(nr_x), sequence(nr_x), y_indices_no_smooth, sequence(nr_x)))

res <- data.frame("Smooth" = c("yes", "no"), "Area" = c(area_smooth, area_no_smooth), "Eucl" = c(dist_smooth, dist_no_smooth))

print(res)

```

## Generate and capture a topology change

Using dyngen, we can also simulate a topology change in the trajectory: a certain transcript factor that does not come to expression. This will lead to a shortened trajectory. 

```{r, generatedata2, cache=TRUE}
backbone <- bblego(
  bblego_start("A", type = "simple", num_modules = 4),
  bblego_linear("A", "B", type = "simple", num_modules = 6),
  bblego_linear("B", "C", type = "simple", num_modules = 6),
  bblego_end("C", type = "simple", num_modules = 4)
)
model1 <-
  initialise_model(
    num_tfs = 20,
    num_targets = 200,
    num_hks = 200,
    num_cells = 1000,
    backbone = backbone,
    verbose = TRUE,
    download_cache_dir = "~/.cache/dyngen",
    num_cores = 8,
    distance_metric = "pearson",
    tf_network_params = tf_network_default(min_tfs_per_module = 1),
    simulation_params = simulation_default(num_simulations = 32, census_interval = .01),
  ) %>%
  generate_tf_network() %>%
  generate_feature_network() %>%
  generate_kinetics() %>%
  generate_gold_standard() %>%
  generate_cells()

model1_ <- generate_experiment(model1)
dataset1 <- wrap_dataset(model1_)

```

We can plot what this network looks like.

```{r, plot_model, cache=TRUE, dependson=c("generatedata2"), collapse=TRUE, fig.height=7, fig.width=7, fig.align = "center"}
plot_backbone_statenet(model1)
plot_backbone_modulenet(model1)
plot_feature_network(model1, show_targets = FALSE)
plot_feature_network(model1)
plot_feature_network(model1, show_hks = TRUE)
```

Next, we will reduce the transcription rate and the mRNA degradation rate of a certain transcription factor to 0. Here, we choose the transcription factor C1_TF1, because it is the fist transcription factor of C1. This makes it easy to later calculate with which percentage of the original trajectory this new trajectory will overlap.

```{r, generate_topology_change, cache=TRUE, dependson=c("generatedata2")}
change_speed <- function(model, target, rate) {
  param_id <- which(target == model$feature_info$feature_id)[[1]]

  model$feature_info$wpr[param_id] <- model$feature_info$wpr[param_id] * rate
  model$feature_info$xdr[param_id] <- model$feature_info$xdr[param_id] * rate

  param_wpr <- paste0("wpr_", target)
  param_xdr <- paste0("xdr_", target)

  model$simulation_system$parameters[param_wpr] <- model$simulation_system$parameters[param_wpr] * rate
  model$simulation_system$parameters[param_xdr] <- model$simulation_system$parameters[param_xdr] * rate

  model
}


model2 <- change_speed(model1, "C1_TF1", 0)
model2 <- generate_gold_standard(model2)
model2 <- generate_cells(model2)

model2_ <- generate_experiment(model2)
dataset2 <- wrap_dataset(model2_)
```

We can merge the models again and plot them in the same dimensionality reduction.

```{r, plot_topology_change, cache=TRUE, dependson=c("generatedata2", "generate_topology_change")}
model12 <- merge_models(model1, model1, model2)
model12 <- model12 %>%
  dyngen:::calculate_dimred(dimred_premrna = FALSE) %>%
  generate_experiment()

dataset <- wrap_dataset(model12)
plot_gold_simulations(model12)
plot_dimred(dataset)
plot_graph(dataset)
```

We can again calculate the dynamic time warping, both on smoothed and unsmoothed data.

```{r, dtw_topology_smoothed, cache=TRUE, dependson=c("generatedata2", "generate_topology_change")}
nr_wps <- 1000

wpp1 <- get_waypoint_progression(dataset1, nr_wps)
wpp2 <- get_waypoint_progression(dataset2, nr_wps)

gd1 <- get_geodesic_distances_from_progressions(dataset1, wpp1)
gd2 <- get_geodesic_distances_from_progressions(dataset2, wpp2)

wexpr1 <- interpolate_expression(dataset1, wpp1$percentage, gd1)
wexpr2 <- interpolate_expression(dataset2, wpp2$percentage, gd2)

d2 <- dist(as.matrix(t(wexpr2)), as.matrix(t(wexpr1)), dist.method="pearson")
am2 <- dtw(as.matrix(t(wexpr2)), as.matrix(t(wexpr1)), step.pattern = symmetric2, keep.internals = TRUE, open.end = FALSE)

```

```{r, dtw_topology_unsmoothed, cache=TRUE, dependson=c("generatedata2", "generate_topology_change")}
nor1 <- names(sort(calculate_correct_pseudotime(dataset1)))
volg1 <- sapply(nor1, function(i) strtoi(substr(i, 5, 7)))
cnt1 <- as.matrix(dataset1$counts)
cnts1 <- cnt1[volg1,]

nor2 <- names(sort(calculate_correct_pseudotime(dataset2)))
volg2 <- sapply(nor2, function(i) strtoi(substr(i, 5, 7)))
cnt2 <- as.matrix(dataset2$counts)
cnts2 <- cnt2[volg2,]

d3 <- dist(cnts2, cnts1, dist.method="pearson")
am3 <- dtw(d3, step.pattern = symmetric2, keep.internals = TRUE, open.end = FALSE)
```

We can plot both dynamic time warpings. The indicated slope is the trajectory of the warping path we expect. Because we surpressed the transcription rate and the mrna degradation rate of C1_TF1, we don't expect there to be any expression past that point. We know how long the different parts of the trajectory are, and we also know that the amount of milestones is linked to the length of the trajectory parts.

This means that, if the length of the milestone network between A and C is 66% of the complete length, we expect the whole of the shortened trajectory to match to the first 66% of the complete trajectory.


```{r, plot_topology_dtw, cache=TRUE, dependson=c("dtw_topology_smoothed", "dtw_topology_unsmoothed"), collapse=TRUE, fig.height=7, fig.width=7, fig.align = "center"}

dtwPlotDensity(am2)
abline(coef= c(0, sum(dataset1$milestone_network$length[1:2]) / sum(dataset1$milestone_network$length)))
dtwPlotDensity(am3)
abline(coef = c(0, sum(dataset1$milestone_network$length[1:2]) / sum(dataset1$milestone_network$length)))
```

```{r}
# Calculate euclidean distance metric


```

<!-- library(MESS) -->

<!-- get_y_indices <- function(nr_points, index1, index2){ -->
<!--   xymap <- rep(list(), length = nr_points) -->
<!--   for(i in 1:length(index1)){ -->
<!--     x_index = index1[[i]] -->
<!--     y_index = index2[[i]] -->
<!--     xymap[[x_index]] <- c(xymap[[x_index]], y_index) -->
<!--   } -->

<!--   sapply(sequence(nr_points), function(i) max(xymap[[i]])) -->
<!-- } -->

<!-- eucl_dist <- function(x1, x2, y1, y2){ -->
<!--   sqrt((x1 - x2)^2 + (y1 - y2)^2) -->
<!-- } -->

<!-- nr_x <- length(unique(am2$index1)) -->

<!-- y_indices_smooth <- get_y_indices(length(unique(am2$index1)), am2$index1, am2$index2) -->
<!-- y_indices_no_smooth <- get_y_indices(length(unique(am2$index1)), am3$index1, am3$index2) -->

<!-- area_smooth <- MESS::auc(sequence(nr_x), y_indices_smooth - sequence(nr_x), absolutearea = TRUE) -->
<!-- dist_smooth <- sum(eucl_dist(sequence(nr_x), sequence(nr_x), y_indices_smooth, sequence(nr_x))) -->

<!-- area_no_smooth <- MESS::auc(sequence(nr_x), y_indices_no_smooth - sequence(nr_x), absolutearea = TRUE) -->
<!-- dist_no_smooth <- sum(eucl_dist(sequence(nr_x), sequence(nr_x), y_indices_no_smooth, sequence(nr_x))) -->

<!-- res <- data.frame("Smooth" = c("yes", "no"), "Area" = c(area_smooth, area_no_smooth), "Eucl" = c(dist_smooth, dist_no_smooth)) -->

<!-- print(res) -->



